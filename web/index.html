<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>UnderCrypt - Web Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      background: #1a1a1a;
      color: #eee;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .app {
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #1a1a1a;
      color: #eee;
    }

    .app-header {
      background: #222;
      border-bottom: 2px solid #555;
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .app-header h1 {
      font-size: 24px;
      margin: 0;
    }

    .start-btn {
      background: #4a9;
      border: none;
      border-radius: 6px;
      padding: 10px 20px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }

    .start-btn:hover {
      background: #3a8;
      box-shadow: 0 0 12px rgba(74, 170, 153, 0.5);
    }

    .start-screen {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 20px;
      text-align: center;
    }

    .start-screen h2 {
      font-size: 32px;
    }

    .start-screen p {
      font-size: 18px;
      color: #aaa;
    }

    .game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .game-board {
      display: flex;
      flex-direction: column;
      gap: 20px;
      height: 100%;
      padding: 20px;
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      overflow-y: auto;
    }

    .top-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      flex: 1;
      min-height: 250px;
    }

    .hero-panel,
    .enemy-panel {
      background: #333;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      overflow-y: auto;
    }

    .hero-panel h2,
    .enemy-panel h2 {
      margin-bottom: 15px;
      color: #fff;
    }

    .stats {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
    }

    .stat span:first-child {
      min-width: 60px;
      color: #aaa;
    }

    .hp-bar {
      flex: 1;
      height: 20px;
      background: #222;
      border-radius: 4px;
      overflow: hidden;
      border: 1px solid #444;
    }

    .hp-fill {
      height: 100%;
      transition: width 0.3s ease;
    }

    .stat strong {
      color: #fff;
      font-size: 16px;
    }

    .enemies {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
    }

    .enemy {
      background: #2a2a2a;
      border: 2px solid #666;
      border-radius: 6px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .enemy:hover:not(.defeated) {
      border-color: #f44;
      box-shadow: 0 0 8px rgba(255, 68, 68, 0.3);
    }

    .enemy.defeated {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .enemy .name {
      font-weight: bold;
      color: #fff;
      margin-bottom: 5px;
    }

    .enemy .hp {
      color: #4a9;
      font-size: 12px;
    }

    .enemy .attack {
      color: #f44;
      font-size: 12px;
    }

    .bottom-section {
      display: flex;
      flex-direction: column;
      gap: 15px;
      background: #333;
      border: 2px solid #555;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      max-height: 200px;
    }

    .hand-panel h3 {
      color: #aaa;
      font-size: 14px;
    }

    .hand {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      overflow-y: auto;
    }

    .card-btn {
      background: #2a2a2a;
      border: 2px solid #666;
      border-radius: 6px;
      padding: 10px;
      color: #fff;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 100px;
      text-align: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    .card-btn:hover:not(:disabled) {
      border-color: #4a9;
      box-shadow: 0 0 8px rgba(74, 170, 153, 0.3);
      transform: translateY(-2px);
    }

    .card-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      border-color: #444;
    }

    .card-btn.attack {
      border-color: #f44;
    }

    .card-btn.defense {
      border-color: #4a9;
    }

    .card-btn.spell {
      border-color: #f4a;
    }

    .card-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .card-cost {
      background: #444;
      border-radius: 3px;
      padding: 2px 6px;
      display: inline-block;
      font-size: 11px;
      margin-bottom: 5px;
    }

    .card-effect {
      font-size: 10px;
      color: #aaa;
    }

    .effect {
      margin: 2px 0;
    }

    .end-turn-btn {
      background: #4a9;
      border: none;
      border-radius: 6px;
      padding: 12px 20px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
      align-self: flex-end;
      white-space: nowrap;
    }

    .end-turn-btn:hover {
      background: #3a8;
      box-shadow: 0 0 12px rgba(74, 170, 153, 0.5);
      transform: scale(1.05);
    }

    .end-turn-btn:active {
      transform: scale(0.95);
    }

    .message {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: #f44;
      color: #fff;
      padding: 10px 15px;
      border-radius: 4px;
      font-size: 14px;
      animation: fadeIn 0.2s;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .game-over {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }

    .game-over .modal {
      background: #333;
      border: 2px solid #4a9;
      border-radius: 8px;
      padding: 30px;
      text-align: center;
      min-width: 300px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    .game-over .modal p {
      font-size: 18px;
      margin-bottom: 20px;
    }

    .game-over .modal button {
      background: #4a9;
      border: none;
      border-radius: 6px;
      padding: 12px 24px;
      color: #fff;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
    }

    .game-over .modal button:hover {
      background: #3a8;
      box-shadow: 0 0 12px rgba(74, 170, 153, 0.5);
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header class="app-header">
      <h1>UnderCrypt - Web Demo</h1>
      <button class="start-btn" id="newGameBtn" style="display: none;">New Game</button>
    </header>

    <div class="start-screen" id="startScreen">
      <h2>Welcome to UnderCrypt</h2>
      <p>A deck-building dungeon crawler</p>
      <button class="start-btn" onclick="gameState.startGame()">Start Game</button>
    </div>

    <div class="game-container hidden" id="gameContainer">
      <div class="game-board" id="gameBoard"></div>
      <div class="message hidden" id="message"></div>
      <div class="game-over hidden" id="gameOverModal">
        <div class="modal">
          <p id="gameOverMessage"></p>
          <button onclick="gameState.startGame()">Play Again</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Game Data
    const cards = [
      {
        id: 'knight_strike',
        name: "Knight's Strike",
        type: 'Attack',
        cost: 1,
        effects: [{ type: 'damage', value: 6, target: 'enemy' }],
      },
      {
        id: 'defend',
        name: 'Defend',
        type: 'Defense',
        cost: 1,
        effects: [{ type: 'block', value: 5, target: 'self' }],
      },
      {
        id: 'flame_burst',
        name: 'Flame Burst',
        type: 'Spell',
        cost: 2,
        effects: [{ type: 'damage', value: 8, target: 'all_enemies' }],
      },
      {
        id: 'heal_potion',
        name: 'Heal Potion',
        type: 'Spell',
        cost: 1,
        effects: [{ type: 'heal', value: 10, target: 'self' }],
      },
    ];

    const heroes = [
      {
        id: 'knight_of_ashes',
        name: 'Knight of Ashes',
        class: 'Warrior',
        baseHP: 80,
        handSize: 5,
        startingDeck: ['knight_strike', 'defend', 'defend', 'knight_strike', 'defend'],
        passive: 'Tough',
        active: 'Bash',
      },
    ];

    const monsters = [
      { id: 'giant_rat', name: 'Giant Rat', type: 'Minion', hp: 25, attack: 8 },
      { id: 'spider', name: 'Giant Spider', type: 'Minion', hp: 20, attack: 6 },
    ];

    // Game Engine
    function shuffle(arr) {
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function startGame(data, heroId) {
      const hero = data.heroes.find((h) => h.id === heroId);
      if (!hero) throw new Error('Hero not found');

      const deck = hero.startingDeck.map((id) => {
        const card = data.cards.find((c) => c.id === id);
        if (!card) throw new Error('Card not found');
        return { ...card };
      });

      const shuffled = shuffle(deck);

      const state = {
        hero: { ...hero, hp: hero.baseHP, block: 0 },
        deck: shuffled,
        hand: [],
        discard: [],
        enemies: [],
        energy: 3,
        maxEnergy: 3,
      };

      drawToHandSize(state);
      return state;
    }

    function drawToHandSize(state) {
      while (state.hand.length < state.hero.handSize) {
        if (state.deck.length === 0) {
          state.deck = shuffle(state.discard.splice(0));
        }
        const card = state.deck.shift();
        if (!card) break;
        state.hand.push(card);
      }
    }

    function startTurn(state) {
      state.energy = state.maxEnergy;
      state.hero.block = 0;
      drawToHandSize(state);
    }

    function playCard(state, handIndex, targetIndex = 0) {
      const card = state.hand[handIndex];
      if (!card) throw new Error('No card at hand index');
      if (card.cost > state.energy) throw new Error('Not enough energy');
      state.energy -= card.cost;

      for (const eff of card.effects) {
        if (eff.type === 'damage') {
          if (state.enemies[targetIndex]) {
            state.enemies[targetIndex].hp -= eff.value;
          }
          if (eff.target === 'all_enemies') {
            state.enemies.forEach((e) => (e.hp -= eff.value));
          }
        } else if (eff.type === 'block') {
          state.hero.block += eff.value;
        } else if (eff.type === 'heal') {
          state.hero.hp = Math.min(state.hero.baseHP, state.hero.hp + eff.value);
        }
      }

      state.discard.push(...state.hand.splice(handIndex, 1));
    }

    function enemyTurn(state) {
      for (const m of state.enemies) {
        if (m.hp <= 0) continue;
        const dmg = Math.max(0, m.attack - state.hero.block);
        state.hero.hp -= dmg;
      }
    }

    // Game State
    const gameState = {
      state: null,
      gameOver: false,
      message: '',

      startGame() {
        const data = { cards, heroes, monsters };
        this.state = startGame(data, 'knight_of_ashes');
        this.state.enemies = [{ ...shuffle(monsters.slice(0, 2))[0] }];
        this.gameOver = false;
        this.message = '';
        this.render();
      },

      playCard(handIndex) {
        if (!this.state) return;
        try {
          playCard(this.state, handIndex, 0);
          this.message = '';
          this.render();
        } catch (e) {
          this.message = e.message;
          this.render();
        }
      },

      endTurn() {
        if (!this.state) return;

        this.state.enemies = this.state.enemies.filter((e) => e.hp > 0);

        if (this.state.enemies.length === 0) {
          this.gameOver = true;
          this.message = 'Victory! All enemies defeated.';
          this.render();
          return;
        }

        enemyTurn(this.state);
        this.render();

        if (this.state.hero.hp <= 0) {
          this.gameOver = true;
          this.message = 'Defeat! Hero HP reached 0.';
          this.render();
          return;
        }

        startTurn(this.state);
        this.render();
      },

      render() {
        if (!this.state) return;

        const startScreen = document.getElementById('startScreen');
        const gameContainer = document.getElementById('gameContainer');
        const gameBoard = document.getElementById('gameBoard');
        const messageEl = document.getElementById('message');
        const gameOverModal = document.getElementById('gameOverModal');
        const newGameBtn = document.getElementById('newGameBtn');

        startScreen.classList.add('hidden');
        gameContainer.classList.remove('hidden');
        newGameBtn.style.display = 'block';

        gameBoard.innerHTML = `
          <div class="top-section">
            <div class="hero-panel">
              <h2>${this.state.hero.name}</h2>
              <div class="stats">
                <div class="stat">
                  <span>HP:</span>
                  <div class="hp-bar">
                    <div class="hp-fill" style="width: ${(this.state.hero.hp / this.state.hero.baseHP) * 100}%; background-color: ${this.state.hero.hp / this.state.hero.baseHP > 0.5 ? '#4a9' : this.state.hero.hp / this.state.hero.baseHP > 0.2 ? '#fa4' : '#f44'}"></div>
                  </div>
                  <span>${this.state.hero.hp}/${this.state.hero.baseHP}</span>
                </div>
                <div class="stat">
                  <span>Block:</span> <strong>${this.state.hero.block}</strong>
                </div>
                <div class="stat">
                  <span>Energy:</span> <strong>${this.state.energy}/${this.state.maxEnergy}</strong>
                </div>
              </div>
            </div>
            <div class="enemy-panel">
              <h2>Enemies (${this.state.enemies.filter((e) => e.hp > 0).length})</h2>
              <div class="enemies">
                ${this.state.enemies
                  .map(
                    (e, i) => `
                  <div class="enemy ${e.hp <= 0 ? 'defeated' : ''}">
                    <div class="name">${e.name}</div>
                    <div class="hp">HP: ${e.hp}</div>
                    <div class="attack">ATK: ${e.attack}</div>
                  </div>
                `
                  )
                  .join('')}
              </div>
            </div>
          </div>
          <div class="bottom-section">
            <h3>Hand (${this.state.hand.length}/${this.state.hero.handSize})</h3>
            <div class="hand">
              ${this.state.hand
                .map(
                  (card, i) => `
                <button class="card-btn ${card.type.toLowerCase()} ${card.cost > this.state.energy ? 'disabled' : ''}"
                  onclick="gameState.playCard(${i})" ${card.cost > this.state.energy ? 'disabled' : ''}>
                  <div class="card-name">${card.name}</div>
                  <div class="card-cost">${card.cost}</div>
                  <div class="card-effect">
                    ${card.effects.map((e) => `<div class="effect">${e.type}: ${e.value}</div>`).join('')}
                  </div>
                </button>
              `
                )
                .join('')}
            </div>
            <button class="end-turn-btn" onclick="gameState.endTurn()">End Turn</button>
          </div>
        `;

        if (this.message) {
          messageEl.textContent = this.message;
          messageEl.classList.remove('hidden');
        } else {
          messageEl.classList.add('hidden');
        }

        if (this.gameOver) {
          document.getElementById('gameOverMessage').textContent = this.message;
          gameOverModal.classList.remove('hidden');
        } else {
          gameOverModal.classList.add('hidden');
        }
      },
    };

    // Initialize
    document.getElementById('newGameBtn').onclick = () => gameState.startGame();
  </script>
</body>
</html>
